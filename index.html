<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fast Chat – S1 프런트</title>
  <style>
    :root { --maxw: 820px; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, "Apple SD Gothic Neo", sans-serif; margin: 0; background: #0b0f14; color: #e6edf3; }
    .wrap { max-width: var(--maxw); margin: 0 auto; padding: 24px 16px 120px; }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
    h1 { font-size: 18px; font-weight: 700; margin: 0; letter-spacing: .2px; }
    .latency { font-size: 12px; opacity: .75; }
    .chat { display: flex; flex-direction: column; gap: 10px; }
    .msg { padding: 12px 14px; border-radius: 14px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
    .user { background: #1b2530; align-self: flex-end; border: 1px solid #253247; }
    .bot { background: #0f1720; align-self: flex-start; border: 1px solid #1a2635; }
    .pending { opacity: .85; }
    .sys { align-self: center; font-size: 12px; opacity: .7; }
    .footer { position: fixed; left: 0; right: 0; bottom: 0; background: #0d141b; border-top: 1px solid #1a2432; }
    .inp { max-width: var(--maxw); margin: 0 auto; display: grid; gap: 8px; grid-template-columns: 1fr auto auto; padding: 12px 16px; }
    textarea { resize: none; width: 100%; height: 44px; padding: 12px; border-radius: 12px; border: 1px solid #233045; background: #0b121a; color: #e6edf3; outline: none; }
    button { height: 44px; border-radius: 12px; border: 1px solid #2a3950; background: #15202b; color: #e6edf3; padding: 0 14px; cursor: pointer; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    .hint { grid-column: 1 / -1; font-size: 12px; opacity: .7; }
    .link { color: #9bd2ff; text-decoration: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>⚡ Fast Chat (S1)</h1>
      <div class="latency" id="latency">TTFB: — / Done: —</div>
    </header>

    <div id="chat" class="chat" aria-live="polite" aria-busy="false"></div>
  </div>

  <div class="footer">
    <div class="inp">
      <textarea id="input" placeholder="무엇이든 물어보세요… (Enter=전송, Shift+Enter=줄바꿈)" spellcheck="false"></textarea>
      <button id="send">전송</button>
      <button id="cancel" disabled>중단</button>
      <div class="hint">
        <strong>엔드포인트:</strong> <code id="endpointLbl"></code> · 
        <span>나중에 S2에서 Cloudflare Workers의 <code>/chat</code>로 변경합니다.</span>
      </div>
    </div>
  </div>

<script>
/*****
 * S1 설정: 프런트에서 호출할 API 경로
 * - S2에서 Cloudflare Workers가 준비되면, 아래 API_URL을 해당 URL로 교체하세요.
 *   예) https://your-worker-subdomain.workers.dev/chat
 * - 같은 도메인에서 Pages Functions/Workers 라우팅을 쓴다면 '/chat'로 두셔도 됩니다.
 * - 임시 테스트(백엔드 없이)하려면 API_URL을 빈 문자열로 두고 USE_MOCK=true 로 두세요.
 *****/
const API_URL = "https://stream-chat-worker.koreavisa.workers.dev/chat";; // 예: "https://your-worker-subdomain.workers.dev/chat" 또는 "/chat"
const USE_MOCK = false; // 백엔드 없이 UI 동작 확인용. S2 완료 후 false로 변경.

document.getElementById('endpointLbl').textContent = API_URL || (USE_MOCK ? '(MOCK 모드)' : '(미설정)');

const $chat = document.getElementById('chat');
const $input = document.getElementById('input');
const $send = document.getElementById('send');
const $cancel = document.getElementById('cancel');
const $latency = document.getElementById('latency');

let controller = null; // AbortController

function addMsg(role, text, pending=false) {
  const div = document.createElement('div');
  div.className = `msg ${role} ${pending ? 'pending' : ''}`;
  div.textContent = text;
  $chat.appendChild(div);
  $chat.scrollTop = $chat.scrollHeight;
  return div;
}

function addSys(text) {
  const div = document.createElement('div');
  div.className = 'sys';
  div.textContent = text;
  $chat.appendChild(div);
  $chat.scrollTop = $chat.scrollHeight;
  return div;
}

function setBusy(b) {
  $send.disabled = b;
  $cancel.disabled = !b;
  $chat.setAttribute('aria-busy', String(b));
}

function fmtMs(ms) { return ms ? `${ms}ms` : '—'; }

async function send() {
  const text = $input.value.trim();
  if (!text) return;
  $input.value = '';
  const u = addMsg('user', text);

  // 준비
  setBusy(true);
  let t0 = performance.now();
  let tFirst = null;
  $latency.textContent = `TTFB: … / Done: …`;

  // 봇 메시지 컨테이너(스트리밍으로 계속 붙임)
  const bot = addMsg('bot', '', true);

  try {
    if (USE_MOCK || !API_URL) {
      // 백엔드 없이 UI 테스트용 모의 스트리밍
      await mockStream(bot, t0, (msFirst)=>{
        tFirst = msFirst; $latency.textContent = `TTFB: ${fmtMs(tFirst)} / Done: …`; });
    } else {
      controller = new AbortController();
      const resp = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: text }),
        signal: controller.signal,
      });

      if (!resp.ok || !resp.body) {
        throw new Error(`서버 오류: ${resp.status}`);
      }

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        // 첫 바이트 시간 기록
        if (tFirst === null) {
          tFirst = Math.round(performance.now() - t0);
          $latency.textContent = `TTFB: ${fmtMs(tFirst)} / Done: …`;
        }
        buffer += chunk;

        // SSE 형식 지원(data: ...\n\n), NDJSON, 순수 텍스트 스트림 모두 처리
        // 1) SSE 파싱
        // if ((resp.headers.get('content-type')||'').includes('text/event-stream')) {
        //   const parts = buffer.split('\n\n');
        //   buffer = parts.pop();
        //   for (const p of parts) {
        //     const line = p.split('\n').find(l => l.startsWith('data:')) || '';
        //     const data = line.replace(/^data:\s?/, '');
        //     if (!data || data === '[DONE]') continue;
        //     bot.textContent += data;
        //   }
        // } else {
        //   // 2) NDJSON 또는 텍스트 스트림
        //   // NDJSON이면 줄단위 JSON으로 누적
        //   const lines = buffer.split('\n');
        //   buffer = lines.pop();
        //   for (const ln of lines) {
        //     const t = ln.trim();
        //     if (!t) continue;
        //     try {
        //       const obj = JSON.parse(t);
        //       if (obj.delta) bot.textContent += obj.delta; // {"delta": "..."}
        //       else if (obj.text) bot.textContent += obj.text;
        //       else bot.textContent += t;
        //     } catch { // 순수 텍스트로 취급
        //       bot.textContent += t;
        //     }
        //   }
        // }
        const isSSE = (resp.headers.get('content-type') || '').includes('text/event-stream');
        if (isSSE) {
          // SSE 프레임(빈 줄 \n\n로 구분) 안의 data: 라인들을 모아 JSON이면 delta.content만 꺼냄
          const parts = buffer.split('\n\n');
          buffer = parts.pop();
          for (const p of parts) {
            const dataLines = p.split('\n')
              .filter(l => l.startsWith('data:'))
              .map(l => l.replace(/^data:\s?/, ''));
            for (const data of dataLines) {
              if (!data || data === '[DONE]') continue;
              let out = '';
              try {
                const obj = JSON.parse(data);
                if (obj?.choices?.length) {
                  for (const ch of obj.choices) out += (ch?.delta?.content || ch?.text || '');
                }
              } catch {
                // JSON이 아니면 원문 텍스트로
                out = data;
              }
              if (out) bot.textContent += out;
            }
          }
        } else {
          // NDJSON/텍스트 스트림도 JSON이면 delta/text 우선으로 출력
          const lines = buffer.split('\n');
          buffer = lines.pop();
          for (const ln of lines) {
            const t = ln.trim();
            if (!t) continue;
            try {
              const obj = JSON.parse(t);
              const out = (obj?.delta ?? obj?.text ?? obj?.choices?.[0]?.delta?.content ?? '');
              bot.textContent += out || t;
            } catch {
              bot.textContent += t;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error(err);
    bot.textContent += `\n[오류] ${err.message || err}`;
  } finally {
    bot.classList.remove('pending');
    setBusy(false);
    const doneMs = Math.round(performance.now() - t0);
    $latency.textContent = `TTFB: ${fmtMs(tFirst)} / Done: ${fmtMs(doneMs)}`;
    controller = null;
  }
}

async function mockStream(el, t0, onFirst) {
  // 150–400ms 사이 랜덤으로 첫 바이트 도착처럼 연출
  const wait = (ms)=> new Promise(r=> setTimeout(r, ms));
  await wait(150 + Math.random()*250);
  onFirst(Math.round(performance.now() - t0));
  const demo = "안녕하세요! 여기는 백엔드 없이 동작하는 MOCK 모드입니다.\n\nS2에서 Cloudflare Workers의 /chat 엔드포인트가 준비되면, 상단의 엔드포인트 설정을 실제 주소로 바꾸고 USE_MOCK=false로 설정하세요.";
  const tokens = demo.split("");
  for (const ch of tokens) {
    el.textContent += ch;
    await wait(8 + Math.random()*10);
  }
}

$send.addEventListener('click', send);
$cancel.addEventListener('click', ()=> { if (controller) controller.abort(); });
$input.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); }
});

addSys('빠른 사용법: 메시지를 입력하고 Enter를 누르세요. 스트리밍으로 바로 표시됩니다.');
</script>
</body>
</html>
